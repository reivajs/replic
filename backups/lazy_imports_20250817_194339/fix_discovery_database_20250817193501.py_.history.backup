#!/usr/bin/env python3
"""
ğŸ§¹ REGISTRY CLEANUP - FIX AUTOMÃTICO
===================================

Elimina automÃ¡ticamente todas las referencias al registry
y limpia el proyecto para arquitectura microservicios pura.

Usage: python registry_cleanup.py
"""

import os
import re
import shutil
from pathlib import Path
from datetime import datetime

class RegistryCleanup:
    """Limpieza automÃ¡tica de registry"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.backup_dir = None
        self.files_to_fix = [
            "app/core/dependencies.py",
            "app/api/v1/health.py", 
            "app/services/dashboard_service_enhanced.py",
            "app/services/watermark_service.py"
        ]
        self.fixes_applied = []
    
    def create_backup(self):
        """Crear backup de archivos que se van a modificar"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.backup_dir = self.project_root / "backups" / f"registry_cleanup_{timestamp}"
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        for file_path in self.files_to_fix:
            full_path = self.project_root / file_path
            if full_path.exists():
                backup_file = self.backup_dir / f"{full_path.name}.backup"
                shutil.copy2(full_path, backup_file)
                print(f"ğŸ’¾ Backed up: {file_path}")
        
        return self.backup_dir
    
    def clean_registry_imports(self, content):
        """Limpiar imports del registry"""
        lines = content.split('\n')
        cleaned_lines = []
        
        for line in lines:
            # Eliminar lÃ­neas que importan registry
            if 'from app.services.registry import' in line:
                print(f"  âŒ Removed: {line.strip()}")
                continue
            
            # Eliminar lÃ­neas que usan service_registry
            if 'service_registry.' in line and not line.strip().startswith('#'):
                print(f"  âŒ Removed: {line.strip()}")
                continue
            
            cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines)
    
    def add_microservices_imports(self, content, file_path):
        """Agregar imports de microservicios donde sea necesario"""
        
        # Para archivos que necesitan acceso a servicios
        if 'health.py' in file_path or 'dependencies.py' in file_path:
            # Agregar import al inicio si no existe
            if 'from app.main import get_replicator_service' not in content:
                lines = content.split('\n')
                
                # Buscar lugar para insertar import
                insert_index = 0
                for i, line in enumerate(lines):
                    if line.startswith('import ') or line.startswith('from '):
                        insert_index = i + 1
                    elif line.strip() == '':
                        continue
                    else:
                        break
                
                # Insertar import
                new_import = 'from app.main import get_replicator_service, get_watermark_service, get_discord_service'
                lines.insert(insert_index, new_import)
                content = '\n'.join(lines)
                print(f"  âœ… Added microservices imports")
        
        return content
    
    def fix_health_check_calls(self, content):
        """Arreglar llamadas de health check"""
        
        # Reemplazar service_registry.check_all_services() calls
        patterns = [
            (r'service_registry\.check_all_services\(\)', 'self._check_microservices()'),
            (r'await service_registry\.check_all_services\(\)', 'await self._check_microservices()'),
        ]
        
        for pattern, replacement in patterns:
            if re.search(pattern, content):
                content = re.sub(pattern, replacement, content)
                print(f"  âœ… Fixed health check call")
        
        # Agregar mÃ©todo helper si no existe
        if '_check_microservices' not in content and 'check_all_services' in content:
            helper_method = '''
    async def _check_microservices(self):
        """Check microservices health directly"""
        try:
            from app.main import get_replicator_service, get_watermark_service, get_discord_service
            
            healthy = 0
            total = 0
            
            # Check replicator
            replicator = get_replicator_service()
            if replicator:
                total += 1
                try:
                    health = await replicator.get_health()
                    if health.get("status") == "healthy":
                        healthy += 1
                except:
                    pass
            
            # Check watermark
            watermark = get_watermark_service()
            if watermark:
                total += 1
                healthy += 1  # Simple check
            
            # Check discord
            discord = get_discord_service()
            if discord:
                total += 1
                healthy += 1  # Simple check
            
            return healthy, total
        except Exception as e:
            return 0, 1
'''
            
            # Buscar lugar para insertar mÃ©todo (antes del final de la clase)
            lines = content.split('\n')
            insert_index = len(lines) - 1
            
            # Buscar Ãºltima lÃ­nea de una clase
            for i in range(len(lines) - 1, -1, -1):
                if lines[i].strip() and not lines[i].startswith(' ') and not lines[i].startswith('#'):
                    if 'class ' not in lines[i]:
                        insert_index = i + 1
                        break
            
            lines.insert(insert_index, helper_method)
            content = '\n'.join(lines)
            print(f"  âœ… Added _check_microservices helper method")
        
        return content
    
    def process_file(self, file_path):
        """Procesar un archivo especÃ­fico"""
        full_path = self.project_root / file_path
        
        if not full_path.exists():
            print(f"âš ï¸ File not found: {file_path}")
            return False
        
        print(f"\nğŸ”§ Processing: {file_path}")
        
        # Leer contenido
        with open(full_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original_content = content
        
        # Aplicar fixes
        content = self.clean_registry_imports(content)
        content = self.add_microservices_imports(content, file_path)
        content = self.fix_health_check_calls(content)
        
        # Escribir si hubo cambios
        if content != original_content:
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"âœ… Fixed: {file_path}")
            self.fixes_applied.append(file_path)
            return True
        else:
            print(f"â„¹ï¸ No changes needed: {file_path}")
            return False
    
    def clean_pycache(self):
        """Limpiar archivos de cachÃ©"""
        print("\nğŸ§¹ Cleaning Python cache...")
        
        cache_dirs = list(self.project_root.glob("**/__pycache__"))
        
        for cache_dir in cache_dirs:
            if cache_dir.is_dir():
                shutil.rmtree(cache_dir)
                print(f"  ğŸ—‘ï¸ Removed: {cache_dir}")
        
        print("âœ… Cache cleaned")
    
    def run_cleanup(self):
        """Ejecutar limpieza completa"""
        print("ğŸ§¹ REGISTRY CLEANUP - AUTOMATIC FIX")
        print("=" * 45)
        
        # Crear backup
        print("\nğŸ’¾ Creating backup...")
        self.create_backup()
        
        # Procesar archivos
        print("\nğŸ”§ Processing files...")
        for file_path in self.files_to_fix:
            self.process_file(file_path)
        
        # Limpiar cachÃ©
        self.clean_pycache()
        
        # Crear reporte
        self.create_report()
        
        return len(self.fixes_applied) > 0
    
    def create_report(self):
        """Crear reporte de limpieza"""
        print("\n" + "=" * 45)
        print("ğŸ“Š CLEANUP REPORT")
        print("=" * 45)
        
        if self.fixes_applied:
            print(f"âœ… Files fixed: {len(self.fixes_applied)}")
            for file_path in self.fixes_applied:
                print(f"  - {file_path}")
        else:
            print("â„¹ï¸ No files needed fixing")
        
        print(f"\nğŸ’¾ Backup location: {self.backup_dir}")
        
        print("\nğŸ¯ CHANGES MADE:")
        print("  âœ… Removed all service_registry imports")
        print("  âœ… Added direct microservices imports")
        print("  âœ… Fixed health check calls")
        print("  âœ… Added helper methods where needed")
        print("  âœ… Cleaned Python cache")
        
        print("\nğŸš€ NEXT STEPS:")
        print("  1. Restart your application: python main.py")
        print("  2. Test dashboard: http://localhost:8000/dashboard")
        print("  3. Verify no import errors")
        
        print("\nğŸ’¾ ROLLBACK (if needed):")
        if self.backup_dir:
            for file_path in self.fixes_applied:
                file_name = Path(file_path).name
                print(f"  cp {self.backup_dir}/{file_name}.backup {file_path}")

def main():
    """FunciÃ³n principal"""
    print("ğŸ§¹ REGISTRY CLEANUP TOOL")
    print("=" * 30)
    print()
    print("This tool will:")
    print("âœ… Remove all service_registry imports")
    print("âœ… Add direct microservices imports")
    print("âœ… Fix health check calls")
    print("âœ… Clean Python cache")
    print("âœ… Create automatic backups")
    print()
    
    response = input("ğŸ¤” Proceed with cleanup? (y/N): ")
    if response.lower() != 'y':
        print("âŒ Cleanup cancelled")
        return
    
    # Ejecutar cleanup
    cleanup = RegistryCleanup()
    
    try:
        success = cleanup.run_cleanup()
        
        if success:
            print("\nğŸ‰ CLEANUP COMPLETED SUCCESSFULLY!")
            print("Your project is now free of registry dependencies!")
        else:
            print("\nâœ… Project was already clean!")
    
    except Exception as e:
        print(f"\nâŒ Error during cleanup: {e}")
        print("Check backup files for recovery")

if __name__ == "__main__":
    main()