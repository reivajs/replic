#!/usr/bin/env python3
"""
🧹 REGISTRY CLEANUP - FIX AUTOMÁTICO
===================================

Elimina automáticamente todas las referencias al registry
y limpia el proyecto para arquitectura microservicios pura.

Usage: python registry_cleanup.py
"""

import os
import re
import shutil
from pathlib import Path
from datetime import datetime

class RegistryCleanup:
    """Limpieza automática de registry"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.backup_dir = None
        self.files_to_fix = [
            "app/core/dependencies.py",
            "app/api/v1/health.py", 
            "app/services/dashboard_service_enhanced.py",
            "app/services/watermark_service.py"
        ]
        self.fixes_applied = []
    
    def create_backup(self):
        """Crear backup de archivos que se van a modificar"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.backup_dir = self.project_root / "backups" / f"registry_cleanup_{timestamp}"
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        for file_path in self.files_to_fix:
            full_path = self.project_root / file_path
            if full_path.exists():
                backup_file = self.backup_dir / f"{full_path.name}.backup"
                shutil.copy2(full_path, backup_file)
                print(f"💾 Backed up: {file_path}")
        
        return self.backup_dir
    
    def clean_registry_imports(self, content):
        """Limpiar imports del registry"""
        lines = content.split('\n')
        cleaned_lines = []
        
        for line in lines:
            # Eliminar líneas que importan registry
            if 'from app.services.registry import' in line:
                print(f"  ❌ Removed: {line.strip()}")
                continue
            
            # Eliminar líneas que usan service_registry
            if 'service_registry.' in line and not line.strip().startswith('#'):
                print(f"  ❌ Removed: {line.strip()}")
                continue
            
            cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines)
    
    def add_microservices_imports(self, content, file_path):
        """Agregar imports de microservicios donde sea necesario"""
        
        # Para archivos que necesitan acceso a servicios
        if 'health.py' in file_path or 'dependencies.py' in file_path:
            # Agregar import al inicio si no existe
            if 'from app.main import get_replicator_service' not in content:
                lines = content.split('\n')
                
                # Buscar lugar para insertar import
                insert_index = 0
                for i, line in enumerate(lines):
                    if line.startswith('import ') or line.startswith('from '):
                        insert_index = i + 1
                    elif line.strip() == '':
                        continue
                    else:
                        break
                
                # Insertar import
                new_import = 'from app.main import get_replicator_service, get_watermark_service, get_discord_service'
                lines.insert(insert_index, new_import)
                content = '\n'.join(lines)
                print(f"  ✅ Added microservices imports")
        
        return content
    
    def fix_health_check_calls(self, content):
        """Arreglar llamadas de health check"""
        
        # Reemplazar service_registry.check_all_services() calls
        patterns = [
            (r'service_registry\.check_all_services\(\)', 'self._check_microservices()'),
            (r'await service_registry\.check_all_services\(\)', 'await self._check_microservices()'),
        ]
        
        for pattern, replacement in patterns:
            if re.search(pattern, content):
                content = re.sub(pattern, replacement, content)
                print(f"  ✅ Fixed health check call")
        
        # Agregar método helper si no existe
        if '_check_microservices' not in content and 'check_all_services' in content:
            helper_method = '''
    async def _check_microservices(self):
        """Check microservices health directly"""
        try:
            from app.main import get_replicator_service, get_watermark_service, get_discord_service
            
            healthy = 0
            total = 0
            
            # Check replicator
            replicator = get_replicator_service()
            if replicator:
                total += 1
                try:
                    health = await replicator.get_health()
                    if health.get("status") == "healthy":
                        healthy += 1
                except:
                    pass
            
            # Check watermark
            watermark = get_watermark_service()
            if watermark:
                total += 1
                healthy += 1  # Simple check
            
            # Check discord
            discord = get_discord_service()
            if discord:
                total += 1
                healthy += 1  # Simple check
            
            return healthy, total
        except Exception as e:
            return 0, 1
'''
            
            # Buscar lugar para insertar método (antes del final de la clase)
            lines = content.split('\n')
            insert_index = len(lines) - 1
            
            # Buscar última línea de una clase
            for i in range(len(lines) - 1, -1, -1):
                if lines[i].strip() and not lines[i].startswith(' ') and not lines[i].startswith('#'):
                    if 'class ' not in lines[i]:
                        insert_index = i + 1
                        break
            
            lines.insert(insert_index, helper_method)
            content = '\n'.join(lines)
            print(f"  ✅ Added _check_microservices helper method")
        
        return content
    
    def process_file(self, file_path):
        """Procesar un archivo específico"""
        full_path = self.project_root / file_path
        
        if not full_path.exists():
            print(f"⚠️ File not found: {file_path}")
            return False
        
        print(f"\n🔧 Processing: {file_path}")
        
        # Leer contenido
        with open(full_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original_content = content
        
        # Aplicar fixes
        content = self.clean_registry_imports(content)
        content = self.add_microservices_imports(content, file_path)
        content = self.fix_health_check_calls(content)
        
        # Escribir si hubo cambios
        if content != original_content:
            with open(full_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"✅ Fixed: {file_path}")
            self.fixes_applied.append(file_path)
            return True
        else:
            print(f"ℹ️ No changes needed: {file_path}")
            return False
    
    def clean_pycache(self):
        """Limpiar archivos de caché"""
        print("\n🧹 Cleaning Python cache...")
        
        cache_dirs = list(self.project_root.glob("**/__pycache__"))
        
        for cache_dir in cache_dirs:
            if cache_dir.is_dir():
                shutil.rmtree(cache_dir)
                print(f"  🗑️ Removed: {cache_dir}")
        
        print("✅ Cache cleaned")
    
    def run_cleanup(self):
        """Ejecutar limpieza completa"""
        print("🧹 REGISTRY CLEANUP - AUTOMATIC FIX")
        print("=" * 45)
        
        # Crear backup
        print("\n💾 Creating backup...")
        self.create_backup()
        
        # Procesar archivos
        print("\n🔧 Processing files...")
        for file_path in self.files_to_fix:
            self.process_file(file_path)
        
        # Limpiar caché
        self.clean_pycache()
        
        # Crear reporte
        self.create_report()
        
        return len(self.fixes_applied) > 0
    
    def create_report(self):
        """Crear reporte de limpieza"""
        print("\n" + "=" * 45)
        print("📊 CLEANUP REPORT")
        print("=" * 45)
        
        if self.fixes_applied:
            print(f"✅ Files fixed: {len(self.fixes_applied)}")
            for file_path in self.fixes_applied:
                print(f"  - {file_path}")
        else:
            print("ℹ️ No files needed fixing")
        
        print(f"\n💾 Backup location: {self.backup_dir}")
        
        print("\n🎯 CHANGES MADE:")
        print("  ✅ Removed all service_registry imports")
        print("  ✅ Added direct microservices imports")
        print("  ✅ Fixed health check calls")
        print("  ✅ Added helper methods where needed")
        print("  ✅ Cleaned Python cache")
        
        print("\n🚀 NEXT STEPS:")
        print("  1. Restart your application: python main.py")
        print("  2. Test dashboard: http://localhost:8000/dashboard")
        print("  3. Verify no import errors")
        
        print("\n💾 ROLLBACK (if needed):")
        if self.backup_dir:
            for file_path in self.fixes_applied:
                file_name = Path(file_path).name
                print(f"  cp {self.backup_dir}/{file_name}.backup {file_path}")

def main():
    """Función principal"""
    print("🧹 REGISTRY CLEANUP TOOL")
    print("=" * 30)
    print()
    print("This tool will:")
    print("✅ Remove all service_registry imports")
    print("✅ Add direct microservices imports")
    print("✅ Fix health check calls")
    print("✅ Clean Python cache")
    print("✅ Create automatic backups")
    print()
    
    response = input("🤔 Proceed with cleanup? (y/N): ")
    if response.lower() != 'y':
        print("❌ Cleanup cancelled")
        return
    
    # Ejecutar cleanup
    cleanup = RegistryCleanup()
    
    try:
        success = cleanup.run_cleanup()
        
        if success:
            print("\n🎉 CLEANUP COMPLETED SUCCESSFULLY!")
            print("Your project is now free of registry dependencies!")
        else:
            print("\n✅ Project was already clean!")
    
    except Exception as e:
        print(f"\n❌ Error during cleanup: {e}")
        print("Check backup files for recovery")

if __name__ == "__main__":
    main()