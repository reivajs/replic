#!/usr/bin/env python3
"""
ğŸ”„ LAZY IMPORT FIX - SOLUCIÃ“N DEFINITIVA CIRCULAR IMPORTS
========================================================

Convierte todas las importaciones de servicios a lazy imports
para eliminar completamente los circular imports.

Usage: python fix_lazy_imports.py
"""

import re
import shutil
from pathlib import Path
from datetime import datetime

class LazyImportFixer:
    """Fix automÃ¡tico para convertir a lazy imports"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.backup_dir = None
        self.files_to_fix = []
        self.fixes_applied = []
    
    def find_files_to_fix(self):
        """Encontrar archivos que importan servicios de app.main"""
        files_with_imports = []
        
        # Buscar archivos Python que importan de app.main
        for py_file in self.project_root.glob("**/*.py"):
            if py_file.name == "main.py" and "app" in str(py_file.parent):
                continue  # Skip el main.py mismo
            
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Buscar imports problemÃ¡ticos
                if ('from app.main import get_' in content or 
                    'from app.services.registry import' in content):
                    files_with_imports.append(py_file)
                    
            except Exception as e:
                continue
        
        self.files_to_fix = files_with_imports
        return files_with_imports
    
    def create_backup(self):
        """Crear backup de archivos a modificar"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.backup_dir = self.project_root / "backups" / f"lazy_imports_{timestamp}"
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        for file_path in self.files_to_fix:
            if file_path.exists():
                backup_file = self.backup_dir / f"{file_path.name}_{file_path.parent.name}.backup"
                shutil.copy2(file_path, backup_file)
                print(f"ğŸ’¾ Backed up: {file_path}")
        
        return self.backup_dir
    
    def convert_to_lazy_imports(self, content):
        """Convertir imports a lazy imports"""
        
        # 1. Eliminar imports directos de app.main
        content = re.sub(
            r'from app\.main import get_replicator_service.*?\n',
            '',
            content
        )
        
        content = re.sub(
            r'from app\.main import get_replicator_service, get_watermark_service, get_discord_service.*?\n',
            '',
            content
        )
        
        # 2. Eliminar imports de registry que puedan quedar
        content = re.sub(
            r'from app\.services\.registry import.*?\n',
            '',
            content
        )
        
        return content
    
    def add_lazy_helper_methods(self, content, file_path):
        """Agregar mÃ©todos helper lazy"""
        
        # Solo agregar si el archivo realmente necesita servicios
        needs_services = any(pattern in content for pattern in [
            'get_replicator_service()',
            'service_registry',
            'replicator_service',
            'watermark_service',
            'discord_service'
        ])
        
        if not needs_services:
            return content
        
        # Encontrar lugar para insertar helpers (despuÃ©s de imports)
        lines = content.split('\n')
        insert_index = 0
        
        for i, line in enumerate(lines):
            if line.startswith('import ') or line.startswith('from '):
                insert_index = i + 1
            elif line.strip() == '':
                continue
            elif not line.startswith('#'):
                break
        
        # Helpers para acceso lazy a servicios
        lazy_helpers = [
            "",
            "# ============ LAZY SERVICE ACCESS HELPERS ============",
            "",
            "def _get_replicator_service():",
            "    \"\"\"Lazy access to replicator service\"\"\"",
            "    try:",
            "        from app.main import get_replicator_service",
            "        return get_replicator_service()",
            "    except Exception:",
            "        return None",
            "",
            "def _get_watermark_service():",
            "    \"\"\"Lazy access to watermark service\"\"\"",
            "    try:",
            "        from app.main import get_watermark_service",
            "        return get_watermark_service()",
            "    except Exception:",
            "        return None",
            "",
            "def _get_discord_service():",
            "    \"\"\"Lazy access to discord service\"\"\"",
            "    try:",
            "        from app.main import get_discord_service",
            "        return get_discord_service()",
            "    except Exception:",
            "        return None",
            ""
        ]
        
        # Insertar helpers
        lines = lines[:insert_index] + lazy_helpers + lines[insert_index:]
        
        return '\n'.join(lines)
    
    def fix_service_calls(self, content):
        """Arreglar llamadas a servicios para usar lazy helpers"""
        
        # PatrÃ³n 1: get_replicator_service() directo
        content = re.sub(
            r'get_replicator_service\(\)',
            '_get_replicator_service()',
            content
        )
        
        # PatrÃ³n 2: Assignments
        content = re.sub(
            r'replicator = get_replicator_service\(\)',
            'replicator = _get_replicator_service()',
            content
        )
        
        # PatrÃ³n 3: En mÃ©todos de clase
        content = re.sub(
            r'from app\.main import get_replicator_service\s*\n\s*replicator = get_replicator_service\(\)',
            'replicator = _get_replicator_service()',
            content
        )
        
        # PatrÃ³n 4: En try/except blocks - mejorar
        content = re.sub(
            r'from app\.main import get_replicator_service\s*\n\s*replicator = get_replicator_service\(\)\s*\n\s*if replicator and hasattr\(replicator, \'stats\'\):',
            'replicator = _get_replicator_service()\n            if replicator and hasattr(replicator, \'stats\'):',
            content
        )
        
        return content
    
    def fix_health_check_methods(self, content):
        """Arreglar mÃ©todos de health check especÃ­ficamente"""
        
        # Buscar y reemplazar health check patterns
        old_pattern = r'from app\.services\.registry import service_registry\s*healthy, total = 1, 1.*?if hasattr\(service_registry, \'check_all_services\'\):\s*healthy, total = await service_registry\.check_all_services\(\)'
        
        new_pattern = '''healthy, total = 0, 0
            
            # Check services directly
            replicator = _get_replicator_service()
            watermark = _get_watermark_service()
            discord = _get_discord_service()
            
            services_checked = []
            if replicator:
                services_checked.append(replicator)
                try:
                    health = await replicator.get_health()
                    if health.get("status") == "healthy":
                        healthy += 1
                except:
                    pass
                total += 1
            
            if watermark:
                services_checked.append(watermark)
                healthy += 1  # Simple check for watermark
                total += 1
            
            if discord:
                services_checked.append(discord)
                healthy += 1  # Simple check for discord
                total += 1
            
            if total == 0:
                healthy, total = 1, 1  # Default fallback'''
        
        content = re.sub(old_pattern, new_pattern, content, flags=re.DOTALL)
        
        return content
    
    def process_file(self, file_path):
        """Procesar un archivo especÃ­fico"""
        print(f"\nğŸ”§ Processing: {file_path}")
        
        # Leer contenido
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original_content = content
        
        # Aplicar transformaciones
        content = self.convert_to_lazy_imports(content)
        content = self.add_lazy_helper_methods(content, file_path)
        content = self.fix_service_calls(content)
        content = self.fix_health_check_methods(content)
        
        # Escribir si hubo cambios
        if content != original_content:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"âœ… Fixed: {file_path}")
            self.fixes_applied.append(str(file_path))
            return True
        else:
            print(f"â„¹ï¸ No changes needed: {file_path}")
            return False
    
    def run_fix(self):
        """Ejecutar fix completo"""
        print("ğŸ”„ LAZY IMPORT FIXER")
        print("=" * 25)
        
        # Encontrar archivos a arreglar
        print("\nğŸ” Finding files with problematic imports...")
        files = self.find_files_to_fix()
        
        if not files:
            print("âœ… No files found with problematic imports!")
            return True
        
        print(f"ğŸ“ Found {len(files)} files to fix:")
        for file in files:
            print(f"  - {file}")
        
        # Crear backup
        print("\nğŸ’¾ Creating backup...")
        self.create_backup()
        
        # Procesar archivos
        print("\nğŸ”§ Processing files...")
        for file_path in files:
            self.process_file(file_path)
        
        # Crear reporte
        self.create_report()
        
        return len(self.fixes_applied) > 0
    
    def create_report(self):
        """Crear reporte de cambios"""
        print("\n" + "=" * 40)
        print("ğŸ“Š LAZY IMPORT FIX REPORT")
        print("=" * 40)
        
        if self.fixes_applied:
            print(f"âœ… Files fixed: {len(self.fixes_applied)}")
            for file_path in self.fixes_applied:
                print(f"  - {file_path}")
        else:
            print("â„¹ï¸ No files needed fixing")
        
        print(f"\nğŸ’¾ Backup location: {self.backup_dir}")
        
        print("\nğŸ¯ CHANGES MADE:")
        print("  âœ… Removed direct imports from app.main")
        print("  âœ… Added lazy service access helpers")
        print("  âœ… Fixed service method calls")
        print("  âœ… Updated health check patterns")
        print("  âœ… Eliminated circular import issues")
        
        print("\nğŸš€ EXPECTED RESULT:")
        print("  âœ… No more circular import errors")
        print("  âœ… Clean application startup")
        print("  âœ… All routes registered successfully")
        print("  âœ… Dashboard working correctly")
        
        print("\nğŸ§ª NEXT STEPS:")
        print("  1. Restart your application: python main.py")
        print("  2. Verify no import errors in logs")
        print("  3. Test dashboard: http://localhost:8000/dashboard")
        print("  4. Check health endpoint: http://localhost:8000/api/v1/health")

def main():
    """FunciÃ³n principal"""
    print("ğŸ”„ LAZY IMPORT FIXER")
    print("=" * 20)
    print()
    print("This tool will:")
    print("âœ… Convert all service imports to lazy imports")
    print("âœ… Add helper methods for safe service access")
    print("âœ… Fix health check patterns")
    print("âœ… Eliminate circular import issues completely")
    print("âœ… Create automatic backups")
    print()
    
    response = input("ğŸ¤” Proceed with lazy import fix? (y/N): ")
    if response.lower() != 'y':
        print("âŒ Fix cancelled")
        return
    
    # Ejecutar fix
    fixer = LazyImportFixer()
    
    try:
        success = fixer.run_fix()
        
        if success:
            print("\nğŸ‰ LAZY IMPORT FIX COMPLETED!")
            print("Your application should now start without circular import errors!")
        else:
            print("\nâœ… No files needed fixing - project already clean!")
    
    except Exception as e:
        print(f"\nâŒ Error during fix: {e}")
        print("Check backup files for recovery")

if __name__ == "__main__":
    main()