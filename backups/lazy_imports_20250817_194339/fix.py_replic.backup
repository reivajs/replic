#!/usr/bin/env python3
"""
🔄 LAZY IMPORT FIX - SOLUCIÓN DEFINITIVA CIRCULAR IMPORTS
========================================================

Convierte todas las importaciones de servicios a lazy imports
para eliminar completamente los circular imports.

Usage: python fix_lazy_imports.py
"""

import re
import shutil
from pathlib import Path
from datetime import datetime

class LazyImportFixer:
    """Fix automático para convertir a lazy imports"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.backup_dir = None
        self.files_to_fix = []
        self.fixes_applied = []
    
    def find_files_to_fix(self):
        """Encontrar archivos que importan servicios de app.main"""
        files_with_imports = []
        
        # Buscar archivos Python que importan de app.main
        for py_file in self.project_root.glob("**/*.py"):
            if py_file.name == "main.py" and "app" in str(py_file.parent):
                continue  # Skip el main.py mismo
            
            try:
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Buscar imports problemáticos
                if ('from app.main import get_' in content or 
                    'from app.services.registry import' in content):
                    files_with_imports.append(py_file)
                    
            except Exception as e:
                continue
        
        self.files_to_fix = files_with_imports
        return files_with_imports
    
    def create_backup(self):
        """Crear backup de archivos a modificar"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.backup_dir = self.project_root / "backups" / f"lazy_imports_{timestamp}"
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        for file_path in self.files_to_fix:
            if file_path.exists():
                backup_file = self.backup_dir / f"{file_path.name}_{file_path.parent.name}.backup"
                shutil.copy2(file_path, backup_file)
                print(f"💾 Backed up: {file_path}")
        
        return self.backup_dir
    
    def convert_to_lazy_imports(self, content):
        """Convertir imports a lazy imports"""
        
        # 1. Eliminar imports directos de app.main
        content = re.sub(
            r'from app\.main import get_replicator_service.*?\n',
            '',
            content
        )
        
        content = re.sub(
            r'from app\.main import get_replicator_service, get_watermark_service, get_discord_service.*?\n',
            '',
            content
        )
        
        # 2. Eliminar imports de registry que puedan quedar
        content = re.sub(
            r'from app\.services\.registry import.*?\n',
            '',
            content
        )
        
        return content
    
    def add_lazy_helper_methods(self, content, file_path):
        """Agregar métodos helper lazy"""
        
        # Solo agregar si el archivo realmente necesita servicios
        needs_services = any(pattern in content for pattern in [
            'get_replicator_service()',
            'service_registry',
            'replicator_service',
            'watermark_service',
            'discord_service'
        ])
        
        if not needs_services:
            return content
        
        # Encontrar lugar para insertar helpers (después de imports)
        lines = content.split('\n')
        insert_index = 0
        
        for i, line in enumerate(lines):
            if line.startswith('import ') or line.startswith('from '):
                insert_index = i + 1
            elif line.strip() == '':
                continue
            elif not line.startswith('#'):
                break
        
        # Helpers para acceso lazy a servicios
        lazy_helpers = [
            "",
            "# ============ LAZY SERVICE ACCESS HELPERS ============",
            "",
            "def _get_replicator_service():",
            "    \"\"\"Lazy access to replicator service\"\"\"",
            "    try:",
            "        from app.main import get_replicator_service",
            "        return get_replicator_service()",
            "    except Exception:",
            "        return None",
            "",
            "def _get_watermark_service():",
            "    \"\"\"Lazy access to watermark service\"\"\"",
            "    try:",
            "        from app.main import get_watermark_service",
            "        return get_watermark_service()",
            "    except Exception:",
            "        return None",
            "",
            "def _get_discord_service():",
            "    \"\"\"Lazy access to discord service\"\"\"",
            "    try:",
            "        from app.main import get_discord_service",
            "        return get_discord_service()",
            "    except Exception:",
            "        return None",
            ""
        ]
        
        # Insertar helpers
        lines = lines[:insert_index] + lazy_helpers + lines[insert_index:]
        
        return '\n'.join(lines)
    
    def fix_service_calls(self, content):
        """Arreglar llamadas a servicios para usar lazy helpers"""
        
        # Patrón 1: get_replicator_service() directo
        content = re.sub(
            r'get_replicator_service\(\)',
            '_get_replicator_service()',
            content
        )
        
        # Patrón 2: Assignments
        content = re.sub(
            r'replicator = get_replicator_service\(\)',
            'replicator = _get_replicator_service()',
            content
        )
        
        # Patrón 3: En métodos de clase
        content = re.sub(
            r'from app\.main import get_replicator_service\s*\n\s*replicator = get_replicator_service\(\)',
            'replicator = _get_replicator_service()',
            content
        )
        
        # Patrón 4: En try/except blocks - mejorar
        content = re.sub(
            r'from app\.main import get_replicator_service\s*\n\s*replicator = get_replicator_service\(\)\s*\n\s*if replicator and hasattr\(replicator, \'stats\'\):',
            'replicator = _get_replicator_service()\n            if replicator and hasattr(replicator, \'stats\'):',
            content
        )
        
        return content
    
    def fix_health_check_methods(self, content):
        """Arreglar métodos de health check específicamente"""
        
        # Buscar y reemplazar health check patterns
        old_pattern = r'from app\.services\.registry import service_registry\s*healthy, total = 1, 1.*?if hasattr\(service_registry, \'check_all_services\'\):\s*healthy, total = await service_registry\.check_all_services\(\)'
        
        new_pattern = '''healthy, total = 0, 0
            
            # Check services directly
            replicator = _get_replicator_service()
            watermark = _get_watermark_service()
            discord = _get_discord_service()
            
            services_checked = []
            if replicator:
                services_checked.append(replicator)
                try:
                    health = await replicator.get_health()
                    if health.get("status") == "healthy":
                        healthy += 1
                except:
                    pass
                total += 1
            
            if watermark:
                services_checked.append(watermark)
                healthy += 1  # Simple check for watermark
                total += 1
            
            if discord:
                services_checked.append(discord)
                healthy += 1  # Simple check for discord
                total += 1
            
            if total == 0:
                healthy, total = 1, 1  # Default fallback'''
        
        content = re.sub(old_pattern, new_pattern, content, flags=re.DOTALL)
        
        return content
    
    def process_file(self, file_path):
        """Procesar un archivo específico"""
        print(f"\n🔧 Processing: {file_path}")
        
        # Leer contenido
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        original_content = content
        
        # Aplicar transformaciones
        content = self.convert_to_lazy_imports(content)
        content = self.add_lazy_helper_methods(content, file_path)
        content = self.fix_service_calls(content)
        content = self.fix_health_check_methods(content)
        
        # Escribir si hubo cambios
        if content != original_content:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            print(f"✅ Fixed: {file_path}")
            self.fixes_applied.append(str(file_path))
            return True
        else:
            print(f"ℹ️ No changes needed: {file_path}")
            return False
    
    def run_fix(self):
        """Ejecutar fix completo"""
        print("🔄 LAZY IMPORT FIXER")
        print("=" * 25)
        
        # Encontrar archivos a arreglar
        print("\n🔍 Finding files with problematic imports...")
        files = self.find_files_to_fix()
        
        if not files:
            print("✅ No files found with problematic imports!")
            return True
        
        print(f"📁 Found {len(files)} files to fix:")
        for file in files:
            print(f"  - {file}")
        
        # Crear backup
        print("\n💾 Creating backup...")
        self.create_backup()
        
        # Procesar archivos
        print("\n🔧 Processing files...")
        for file_path in files:
            self.process_file(file_path)
        
        # Crear reporte
        self.create_report()
        
        return len(self.fixes_applied) > 0
    
    def create_report(self):
        """Crear reporte de cambios"""
        print("\n" + "=" * 40)
        print("📊 LAZY IMPORT FIX REPORT")
        print("=" * 40)
        
        if self.fixes_applied:
            print(f"✅ Files fixed: {len(self.fixes_applied)}")
            for file_path in self.fixes_applied:
                print(f"  - {file_path}")
        else:
            print("ℹ️ No files needed fixing")
        
        print(f"\n💾 Backup location: {self.backup_dir}")
        
        print("\n🎯 CHANGES MADE:")
        print("  ✅ Removed direct imports from app.main")
        print("  ✅ Added lazy service access helpers")
        print("  ✅ Fixed service method calls")
        print("  ✅ Updated health check patterns")
        print("  ✅ Eliminated circular import issues")
        
        print("\n🚀 EXPECTED RESULT:")
        print("  ✅ No more circular import errors")
        print("  ✅ Clean application startup")
        print("  ✅ All routes registered successfully")
        print("  ✅ Dashboard working correctly")
        
        print("\n🧪 NEXT STEPS:")
        print("  1. Restart your application: python main.py")
        print("  2. Verify no import errors in logs")
        print("  3. Test dashboard: http://localhost:8000/dashboard")
        print("  4. Check health endpoint: http://localhost:8000/api/v1/health")

def main():
    """Función principal"""
    print("🔄 LAZY IMPORT FIXER")
    print("=" * 20)
    print()
    print("This tool will:")
    print("✅ Convert all service imports to lazy imports")
    print("✅ Add helper methods for safe service access")
    print("✅ Fix health check patterns")
    print("✅ Eliminate circular import issues completely")
    print("✅ Create automatic backups")
    print()
    
    response = input("🤔 Proceed with lazy import fix? (y/N): ")
    if response.lower() != 'y':
        print("❌ Fix cancelled")
        return
    
    # Ejecutar fix
    fixer = LazyImportFixer()
    
    try:
        success = fixer.run_fix()
        
        if success:
            print("\n🎉 LAZY IMPORT FIX COMPLETED!")
            print("Your application should now start without circular import errors!")
        else:
            print("\n✅ No files needed fixing - project already clean!")
    
    except Exception as e:
        print(f"\n❌ Error during fix: {e}")
        print("Check backup files for recovery")

if __name__ == "__main__":
    main()